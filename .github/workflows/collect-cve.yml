name: Collect CVE Data

on:
  schedule:
    - cron: "0 4 * * *"  # Daily at 04:00 UTC
  workflow_dispatch:
    inputs:
      full_sync:
        description: "Full historical sync (fetches 1 year of Linux CVEs)"
        required: false
        type: boolean
        default: false

permissions:
  contents: read

concurrency:
  group: collect-cve-${{ github.ref }}
  cancel-in-progress: true

jobs:
  collect-cve:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Determine sync mode
        id: mode
        run: |
          if [ "${{ inputs.full_sync }}" = "true" ]; then
            echo "mode=full" >> "$GITHUB_OUTPUT"
            echo "Will run FULL historical sync (1 year)"
          else
            echo "mode=incremental" >> "$GITHUB_OUTPUT"
            echo "Will run incremental sync (last 7 days)"
          fi

      - name: Fetch NVD CVEs (incremental)
        if: steps.mode.outputs.mode == 'incremental'
        run: |
          mkdir -p /tmp/nvd_data
          START_DATE=$(date -u -d '7 days ago' +%Y-%m-%dT00:00:00.000)
          END_DATE=$(date -u +%Y-%m-%dT23:59:59.999)
          curl -sSfL --retry 3 --max-time 300 \
            "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=${START_DATE}&lastModEndDate=${END_DATE}&resultsPerPage=2000" \
            -o /tmp/nvd_data/nvd_recent.json
          echo "Downloaded NVD incremental CVEs"

      - name: Fetch NVD CVEs (full — 1 year)
        if: steps.mode.outputs.mode == 'full'
        run: |
          mkdir -p /tmp/nvd_data
          START="$(date -u -d '1 year ago' +%Y-%m-%d)"
          TODAY=$(date -u +%Y-%m-%d)
          PAGE=0

          current="$START"
          while [ "$(date -d "$current" +%s)" -lt "$(date -d "$TODAY" +%s)" ]; do
            next=$(date -u -d "$current + 90 days" +%Y-%m-%d)
            if [ "$(date -d "$next" +%s)" -gt "$(date -d "$TODAY" +%s)" ]; then
              next="$TODAY"
            fi

            S="${current}T00:00:00.000"
            E="${next}T23:59:59.999"
            echo "Fetching CVEs from $current to $next..."

            START_INDEX=0
            while true; do
              OUT="/tmp/nvd_data/page_${PAGE}.json"
              HTTP_CODE=$(curl -sSL --retry 3 --max-time 300 -w "%{http_code}" \
                "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=${S}&lastModEndDate=${E}&resultsPerPage=2000&startIndex=${START_INDEX}" \
                -o "$OUT")

              if [ "$HTTP_CODE" != "200" ]; then
                echo "Warning: got HTTP $HTTP_CODE, skipping"
                rm -f "$OUT"
                break
              fi

              TOTAL=$(python3 -c "import json; print(json.load(open('$OUT')).get('totalResults', 0))")
              RETURNED=$(python3 -c "import json; print(len(json.load(open('$OUT')).get('vulnerabilities', [])))")
              echo "  Page $PAGE: $RETURNED results (total: $TOTAL, offset: $START_INDEX)"
              PAGE=$((PAGE + 1))

              START_INDEX=$((START_INDEX + 2000))
              if [ "$START_INDEX" -ge "$TOTAL" ]; then break; fi
              sleep 6  # NVD rate limit
            done

            current=$(date -u -d "$next + 1 day" +%Y-%m-%d)
            sleep 6
          done
          echo "Downloaded $PAGE NVD pages total"

      # ── CISA Known Exploited Vulnerabilities (KEV) ─────────────────
      # Actively exploited CVEs confirmed by CISA. Used for priority
      # flagging — any CVE in KEV is actively weaponized.
      - name: Fetch CISA KEV catalog
        run: |
          curl -sSfL --retry 3 --max-time 120 \
            "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json" \
            -o /tmp/cisa_kev.json
          COUNT=$(python3 -c "import json; print(len(json.load(open('/tmp/cisa_kev.json')).get('vulnerabilities', [])))")
          echo "CISA KEV: ${COUNT} actively exploited vulnerabilities"

      # ── EPSS (Exploit Prediction Scoring System) ───────────────────
      # Probability of exploitation in the next 30 days. Maintained by
      # FIRST.org. Downloaded as CSV with CVE ID → EPSS score mapping.
      - name: Fetch EPSS scores
        run: |
          curl -sSfL --retry 3 --max-time 300 \
            "https://epss.cyentia.com/epss_scores-current.csv.gz" \
            -o /tmp/epss.csv.gz
          gunzip -f /tmp/epss.csv.gz
          # Skip header comment line and CSV header
          LINES=$(wc -l < /tmp/epss.csv)
          echo "EPSS: ${LINES} CVE scores downloaded"

      - name: Extract and enrich Linux CVEs
        run: |
          python threat-intel/processing/cve_extract.py \
            --input /tmp/nvd_data \
            --output /tmp/cves.jsonl \
            --min-cvss 4.0 \
            --kev /tmp/cisa_kev.json \
            --epss /tmp/epss.csv

      - name: Enforce CVE collector coverage
        env:
          EGUARD_MIN_CVE: "1000"
          EGUARD_MIN_KEV: "50"
        run: |
          python3 - <<'PY'
          import json
          import os
          import pathlib
          import sys

          path = pathlib.Path('/tmp/cves.jsonl')
          if not path.is_file():
              print('cve collector coverage gate failed: missing /tmp/cves.jsonl')
              sys.exit(1)

          cve_count = 0
          kev_count = 0
          for line in path.read_text(encoding='utf-8').splitlines():
              if not line.strip():
                  continue
              cve_count += 1
              try:
                  record = json.loads(line)
              except json.JSONDecodeError:
                  continue
              if record.get('actively_exploited'):
                  kev_count += 1

          min_cve = int(os.environ.get('EGUARD_MIN_CVE', '1000'))
          min_kev = int(os.environ.get('EGUARD_MIN_KEV', '50'))
          print(f'cve extracted count: {cve_count}')
          print(f'cve kev count: {kev_count}')

          failures = []
          if cve_count < min_cve:
              failures.append(f'cve_count too low: {cve_count} < {min_cve}')
          if kev_count < min_kev:
              failures.append(f'cve_kev_count too low: {kev_count} < {min_kev}')

          if failures:
              print('cve collector coverage gate failed:')
              for failure in failures:
                  print(f'- {failure}')
              sys.exit(1)

          print('cve collector coverage gate passed')
          PY

      - name: Upload CVE data as artifact
        uses: actions/upload-artifact@v4
        with:
          name: cve-extracted
          path: /tmp/cves.jsonl
          retention-days: 7
