use crate::types::{EventClass, TelemetryEvent};

const INTERPRETER_MARKERS: &[&str] = &[
    "python -c",
    "python3 -c",
    "perl -e",
    "ruby -e",
    "bash -c",
    "sh -c",
    "zsh -c",
    "pwsh -enc",
    "powershell -enc",
    "powershell -e ",
    "base64 -d",
    "base64 --decode",
];

const TEMP_PATH_TOKENS: &[&str] = &[
    "/tmp/",
    "/var/tmp/",
    "/dev/shm/",
    "/private/tmp/",
    "/private/var/folders/",
    "/var/folders/",
    "/appdata/local/temp/",
    "/windows/temp/",
];

pub fn detect_exploit_indicators(event: &TelemetryEvent) -> Vec<String> {
    if event.event_class != EventClass::ProcessExec {
        return Vec::new();
    }

    let mut indicators = Vec::new();
    let path = event.file_path.as_deref().unwrap_or("");
    let normalized = path.replace('\\', "/");
    let lower = normalized.to_ascii_lowercase();

    if lower.contains("memfd:") {
        indicators.push("fileless_memfd".to_string());
    }

    if lower.contains(" (deleted)") {
        indicators.push("fileless_deleted".to_string());
    }

    if lower.starts_with("/proc/") && lower.contains("/fd/") {
        indicators.push("fileless_procfd".to_string());
    }

    if lower.starts_with("/dev/fd/") {
        indicators.push("fileless_devfd".to_string());
    }

    if has_interpreter_cmdline(event.command_line.as_deref()) && is_temp_path(&lower) {
        indicators.push("fileless_tmp_interpreter".to_string());
    }

    indicators
}

fn has_interpreter_cmdline(cmdline: Option<&str>) -> bool {
    let Some(cmdline) = cmdline else {
        return false;
    };
    let lower = cmdline.to_ascii_lowercase();
    INTERPRETER_MARKERS
        .iter()
        .any(|marker| lower.contains(marker))
}

fn is_temp_path(path: &str) -> bool {
    TEMP_PATH_TOKENS.iter().any(|token| path.contains(token))
}
