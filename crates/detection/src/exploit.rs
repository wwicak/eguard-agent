use crate::types::{EventClass, TelemetryEvent};

const INTERPRETER_MARKERS: &[&str] = &[
    "python -c",
    "python3 -c",
    "perl -e",
    "ruby -e",
    "bash -c",
    "sh -c",
    "zsh -c",
    "pwsh -enc",
    "powershell -enc",
    "powershell -e ",
    "base64 -d",
    "base64 --decode",
];

const TEMP_PATH_TOKENS: &[&str] = &[
    "/tmp/",
    "/var/tmp/",
    "/dev/shm/",
    "/private/tmp/",
    "/private/var/folders/",
    "/var/folders/",
    "/appdata/local/temp/",
    "/windows/temp/",
];

pub fn detect_exploit_indicators(event: &TelemetryEvent) -> Vec<String> {
    if event.event_class != EventClass::ProcessExec {
        return Vec::new();
    }

    let mut indicators = Vec::new();
    let path = event.file_path.as_deref().unwrap_or("");
    let normalized = path.replace('\\', "/");
    let lower = normalized.to_ascii_lowercase();

    if lower.contains("memfd:") {
        indicators.push("fileless_memfd".to_string());
    }

    if lower.contains(" (deleted)") {
        indicators.push("fileless_deleted".to_string());
    }

    if lower.starts_with("/proc/") && lower.contains("/fd/") {
        indicators.push("fileless_procfd".to_string());
    }

    if lower.starts_with("/dev/fd/") {
        indicators.push("fileless_devfd".to_string());
    }

    if has_interpreter_cmdline(event.command_line.as_deref()) && is_temp_path(&lower) {
        push_indicator(&mut indicators, "fileless_tmp_interpreter");
    }

    if has_ld_preload_from_temp(event.command_line.as_deref()) {
        push_indicator(&mut indicators, "fileless_ld_preload");
    }

    if has_pipe_to_interpreter(event.command_line.as_deref()) {
        push_indicator(&mut indicators, "fileless_pipe_exec");
    }

    if has_suspicious_base64_decode_payload(event.command_line.as_deref()) {
        push_indicator(&mut indicators, "encoded_payload_suspicious");
    }

    indicators
}

fn push_indicator(indicators: &mut Vec<String>, name: &str) {
    if !indicators.iter().any(|value| value == name) {
        indicators.push(name.to_string());
    }
}

fn has_interpreter_cmdline(cmdline: Option<&str>) -> bool {
    let Some(cmdline) = cmdline else {
        return false;
    };
    let lower = cmdline.to_ascii_lowercase();
    INTERPRETER_MARKERS
        .iter()
        .any(|marker| lower.contains(marker))
}

fn is_temp_path(path: &str) -> bool {
    TEMP_PATH_TOKENS.iter().any(|token| path.contains(token))
}

fn has_ld_preload_from_temp(cmdline: Option<&str>) -> bool {
    let Some(cmdline) = cmdline else {
        return false;
    };
    let lower = cmdline.to_ascii_lowercase();
    lower.contains("ld_preload=") && is_temp_path(&lower)
}

fn has_pipe_to_interpreter(cmdline: Option<&str>) -> bool {
    let Some(cmdline) = cmdline else {
        return false;
    };
    let lower = cmdline.to_ascii_lowercase();
    if !lower.contains('|') {
        return false;
    }

    let has_download_tool = ["curl", "wget", "fetch", "invoke-webrequest", "iwr"]
        .iter()
        .any(|tool| lower.contains(tool));
    if !has_download_tool {
        return false;
    }

    lower.split('|').skip(1).any(|segment| {
        let trimmed = segment.trim_start();
        [
            "sh",
            "bash",
            "dash",
            "zsh",
            "ksh",
            "pwsh",
            "powershell",
            "python",
            "python3",
            "perl",
            "ruby",
        ]
        .iter()
        .any(|interpreter| has_command_prefix(trimmed, interpreter))
    })
}

fn has_command_prefix(input: &str, cmd: &str) -> bool {
    if !input.starts_with(cmd) {
        return false;
    }
    let rest = &input[cmd.len()..];
    rest.is_empty()
        || rest
            .chars()
            .next()
            .map(|ch| ch.is_ascii_whitespace() || matches!(ch, '-' | '/'))
            .unwrap_or(true)
}

fn has_suspicious_base64_decode_payload(cmdline: Option<&str>) -> bool {
    let Some(cmdline) = cmdline else {
        return false;
    };
    let lower = cmdline.to_ascii_lowercase();
    if !(lower.contains("base64 -d") || lower.contains("base64 --decode")) {
        return false;
    }
    contains_long_base64_run(&lower, 48)
}

fn contains_long_base64_run(input: &str, min_len: usize) -> bool {
    let mut run = 0usize;
    for byte in input.bytes() {
        if is_base64ish(byte) {
            run += 1;
            if run >= min_len {
                return true;
            }
        } else {
            run = 0;
        }
    }
    false
}

fn is_base64ish(byte: u8) -> bool {
    byte.is_ascii_alphanumeric() || matches!(byte, b'+' | b'/' | b'=' | b'-' | b'_')
}
