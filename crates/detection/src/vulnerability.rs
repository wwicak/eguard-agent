//! CVE vulnerability matching engine (CrowdStrike Spotlight equivalent).
//!
//! Indexes CVE entries by product name for O(1) package lookups.
//! Used for real-time detection (ModuleLoad events) and inventory-based
//! vulnerability scanning.

use std::cmp::Ordering;
use std::collections::HashMap;

use serde::Deserialize;

// ── Data types ───────────────────────────────────────────────────────

/// A CVE record as produced by `cve_extract.py` in the threat-intel bundle.
#[derive(Debug, Clone, Deserialize)]
pub struct CveRecord {
    pub cve_id: String,
    #[serde(default)]
    pub severity: String,
    #[serde(default)]
    pub cvss: f64,
    #[serde(default)]
    pub affected_packages: Vec<AffectedPackageRange>,
    #[serde(default)]
    pub actively_exploited: bool,
    #[serde(default)]
    pub epss_score: Option<f64>,
}

/// An affected product with optional version range from NVD CPE match.
#[derive(Debug, Clone, Deserialize)]
pub struct AffectedPackageRange {
    pub product: String,
    #[serde(default)]
    pub version_start: String,
    #[serde(default)]
    pub version_end: String,
}

/// Result of matching an installed package against the CVE database.
#[derive(Debug, Clone)]
pub struct VulnerabilityMatch {
    pub cve_id: String,
    pub cvss: f64,
    pub severity: String,
    pub actively_exploited: bool,
    pub epss_score: f64,
    pub product: String,
    pub installed_version: String,
}

// ── CveDatabase ──────────────────────────────────────────────────────

/// Flattened CVE entry stored per-product in the index.
#[derive(Debug, Clone)]
struct IndexedCve {
    cve_id: String,
    cvss: f64,
    severity: String,
    actively_exploited: bool,
    epss_score: f64,
    version_start: String,
    version_end: String,
}

/// In-memory CVE database indexed by lowercase product name for O(1) lookups.
pub struct CveDatabase {
    index: HashMap<String, Vec<IndexedCve>>,
    total_cves: usize,
}

impl CveDatabase {
    pub fn new() -> Self {
        Self {
            index: HashMap::new(),
            total_cves: 0,
        }
    }

    /// Load CVE records, building the per-product index.
    pub fn load(&mut self, records: impl IntoIterator<Item = CveRecord>) {
        for record in records {
            self.total_cves += 1;
            let epss = record.epss_score.unwrap_or(0.0);
            for pkg in &record.affected_packages {
                let key = pkg.product.to_ascii_lowercase();
                self.index.entry(key).or_default().push(IndexedCve {
                    cve_id: record.cve_id.clone(),
                    cvss: record.cvss,
                    severity: record.severity.clone(),
                    actively_exploited: record.actively_exploited,
                    epss_score: epss,
                    version_start: pkg.version_start.clone(),
                    version_end: pkg.version_end.clone(),
                });
            }
        }
    }

    /// Check a package name + version against the CVE database.
    ///
    /// Returns all CVEs whose version range includes `version`.
    pub fn check_package(&self, name: &str, version: &str) -> Vec<VulnerabilityMatch> {
        let key = name.to_ascii_lowercase();
        let entries = match self.index.get(&key) {
            Some(e) => e,
            None => return Vec::new(),
        };

        entries
            .iter()
            .filter(|e| version_in_range(version, &e.version_start, &e.version_end))
            .map(|e| VulnerabilityMatch {
                cve_id: e.cve_id.clone(),
                cvss: e.cvss,
                severity: e.severity.clone(),
                actively_exploited: e.actively_exploited,
                epss_score: e.epss_score,
                product: name.to_string(),
                installed_version: version.to_string(),
            })
            .collect()
    }

    /// Quick check: does this product have any actively-exploited CVE with CVSS >= 7.0?
    ///
    /// Used for real-time detection where exact version is unavailable.
    pub fn has_critical_cve(&self, product: &str) -> bool {
        let key = product.to_ascii_lowercase();
        self.index.get(&key).map_or(false, |entries| {
            entries
                .iter()
                .any(|e| e.actively_exploited && e.cvss >= 7.0)
        })
    }

    /// Check a loaded module file path for critical CVEs.
    ///
    /// Extracts candidate product names from the path and checks each.
    pub fn check_module_path(&self, file_path: &str) -> bool {
        for candidate in extract_product_candidates(file_path) {
            if self.has_critical_cve(&candidate) {
                return true;
            }
        }
        false
    }

    pub fn len(&self) -> usize {
        self.total_cves
    }

    pub fn is_empty(&self) -> bool {
        self.total_cves == 0
    }
}

impl Default for CveDatabase {
    fn default() -> Self {
        Self::new()
    }
}

// ── Version comparison ───────────────────────────────────────────────

/// Check if `version` falls within [version_start, version_end).
///
/// Empty `version_start` means no lower bound; empty `version_end` means
/// no upper bound. Both empty matches all versions.
fn version_in_range(version: &str, start: &str, end: &str) -> bool {
    if version.is_empty() {
        return false;
    }
    if !start.is_empty() && compare_versions(version, start) == Ordering::Less {
        return false;
    }
    if !end.is_empty() && compare_versions(version, end) != Ordering::Less {
        return false;
    }
    true
}

/// Compare two version strings segment by segment.
///
/// Handles Debian epochs ("2:1.0"), dotted versions ("1.2.3"),
/// and mixed numeric-alpha segments ("1.0.2a").
fn compare_versions(a: &str, b: &str) -> Ordering {
    let a = strip_epoch(a);
    let b = strip_epoch(b);
    let a_parts = split_version(a);
    let b_parts = split_version(b);

    for (ap, bp) in a_parts.iter().zip(b_parts.iter()) {
        let ord = compare_segments(ap, bp);
        if ord != Ordering::Equal {
            return ord;
        }
    }
    a_parts.len().cmp(&b_parts.len())
}

/// Strip Debian epoch prefix: "2:1.0" → "1.0".
fn strip_epoch(v: &str) -> &str {
    match v.find(':') {
        Some(pos) => &v[pos + 1..],
        None => v,
    }
}

/// Split version string on common delimiters.
fn split_version(v: &str) -> Vec<&str> {
    let mut parts = Vec::new();
    let mut start = 0;
    for (i, c) in v.char_indices() {
        if matches!(c, '.' | '-' | '_' | '+' | '~') {
            if i > start {
                parts.push(&v[start..i]);
            }
            start = i + c.len_utf8();
        }
    }
    if start < v.len() {
        parts.push(&v[start..]);
    }
    parts
}

/// Compare a single version segment (numeric or mixed).
fn compare_segments(a: &str, b: &str) -> Ordering {
    match (a.parse::<u64>(), b.parse::<u64>()) {
        (Ok(an), Ok(bn)) => an.cmp(&bn),
        _ => {
            let (a_num, a_alpha) = split_numeric_alpha(a);
            let (b_num, b_alpha) = split_numeric_alpha(b);
            match (a_num, b_num) {
                (Some(an), Some(bn)) => match an.cmp(&bn) {
                    Ordering::Equal => a_alpha.cmp(b_alpha),
                    other => other,
                },
                _ => a.cmp(b),
            }
        }
    }
}

/// Split "2a" into (Some(2), "a"); "abc" into (None, "abc").
fn split_numeric_alpha(s: &str) -> (Option<u64>, &str) {
    let num_end = s
        .char_indices()
        .find(|(_, c)| !c.is_ascii_digit())
        .map(|(i, _)| i)
        .unwrap_or(s.len());
    if num_end == 0 {
        (None, s)
    } else {
        (s[..num_end].parse::<u64>().ok(), &s[num_end..])
    }
}

// ── Module path → product name extraction ────────────────────────────

/// Well-known mappings: shared-library base name → CVE product name.
const LIB_TO_PRODUCT: &[(&str, &str)] = &[
    ("ssl", "openssl"),
    ("crypto", "openssl"),
    ("curl", "curl"),
    ("z", "zlib"),
    ("xml2", "libxml2"),
    ("png", "libpng"),
    ("png16", "libpng"),
    ("tiff", "libtiff"),
    ("freetype", "freetype"),
    ("c", "glibc"),
    ("pthread", "glibc"),
    ("resolv", "glibc"),
    ("python3", "python"),
    ("perl", "perl"),
    ("ruby", "ruby"),
    ("sqlite3", "sqlite"),
    ("pcre2", "pcre2"),
    ("pcre", "pcre"),
    ("ssh2", "libssh2"),
    ("gnutls", "gnutls"),
    ("systemd", "systemd"),
    ("dbus", "dbus"),
];

/// Extract candidate CVE product names from a module file path.
///
/// `/usr/lib/x86_64-linux-gnu/libssl.so.3` → `["openssl", "ssl", "libssl"]`
fn extract_product_candidates(file_path: &str) -> Vec<String> {
    let filename = file_path.rsplit('/').next().unwrap_or(file_path);

    // Strip .so and trailing version: "libssl.so.3.0.0" → "libssl"
    let base = match filename.find(".so") {
        Some(pos) => &filename[..pos],
        None => filename,
    };

    let core = base
        .strip_prefix("lib")
        .unwrap_or(base)
        .to_ascii_lowercase();

    let mut candidates = Vec::with_capacity(3);

    // Check well-known mapping
    for &(lib_name, product) in LIB_TO_PRODUCT {
        if core == lib_name {
            candidates.push(product.to_string());
            break;
        }
    }

    // Also try the core name directly
    if !candidates.iter().any(|c| c == &core) {
        candidates.push(core.clone());
    }

    // Try with "lib" prefix (e.g., "libxml2")
    let base_lower = base.to_ascii_lowercase();
    if !candidates.iter().any(|c| c == &base_lower) {
        candidates.push(base_lower);
    }

    candidates
}

// ── Tests ────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn compare_versions_basic() {
        assert_eq!(compare_versions("1.0.0", "1.0.0"), Ordering::Equal);
        assert_eq!(compare_versions("1.0.0", "1.0.1"), Ordering::Less);
        assert_eq!(compare_versions("1.0.2", "1.0.1"), Ordering::Greater);
        assert_eq!(compare_versions("2.0", "1.9.9"), Ordering::Greater);
    }

    #[test]
    fn compare_versions_different_lengths() {
        assert_eq!(compare_versions("1.0", "1.0.1"), Ordering::Less);
        assert_eq!(compare_versions("1.0.1", "1.0"), Ordering::Greater);
    }

    #[test]
    fn compare_versions_alpha_suffix() {
        assert_eq!(compare_versions("1.0.2a", "1.0.2z"), Ordering::Less);
        assert_eq!(compare_versions("1.0.2z", "1.0.2a"), Ordering::Greater);
    }

    #[test]
    fn compare_versions_epoch() {
        assert_eq!(compare_versions("2:1.0", "1.0"), Ordering::Equal);
        assert_eq!(compare_versions("2:1.0", "1.1"), Ordering::Less);
    }

    #[test]
    fn version_in_range_both_bounds() {
        assert!(version_in_range("1.0.1", "1.0.0", "1.0.2"));
        assert!(version_in_range("1.0.0", "1.0.0", "1.0.2")); // inclusive start
        assert!(!version_in_range("1.0.2", "1.0.0", "1.0.2")); // exclusive end
        assert!(!version_in_range("0.9.9", "1.0.0", "1.0.2"));
    }

    #[test]
    fn version_in_range_open_bounds() {
        assert!(version_in_range("0.1.0", "", "1.0.0")); // no lower bound
        assert!(version_in_range("99.0.0", "1.0.0", "")); // no upper bound
        assert!(version_in_range("5.0.0", "", "")); // all versions match
        assert!(!version_in_range("", "1.0", "2.0")); // empty version never matches
    }

    #[test]
    fn cve_database_load_and_query() {
        let mut db = CveDatabase::new();
        db.load([CveRecord {
            cve_id: "CVE-2024-0001".into(),
            severity: "critical".into(),
            cvss: 9.8,
            affected_packages: vec![AffectedPackageRange {
                product: "openssl".into(),
                version_start: "3.0.0".into(),
                version_end: "3.0.14".into(),
            }],
            actively_exploited: true,
            epss_score: Some(0.95),
        }]);

        assert_eq!(db.len(), 1);

        let matches = db.check_package("openssl", "3.0.5");
        assert_eq!(matches.len(), 1);
        assert_eq!(matches[0].cve_id, "CVE-2024-0001");
        assert!(matches[0].actively_exploited);

        // Version outside range
        assert!(db.check_package("openssl", "3.0.14").is_empty());
        assert!(db.check_package("openssl", "2.9.0").is_empty());

        // Unknown product
        assert!(db.check_package("unknown-pkg", "1.0").is_empty());
    }

    #[test]
    fn has_critical_cve_filters_correctly() {
        let mut db = CveDatabase::new();
        db.load([
            CveRecord {
                cve_id: "CVE-2024-0001".into(),
                severity: "critical".into(),
                cvss: 9.8,
                affected_packages: vec![AffectedPackageRange {
                    product: "openssl".into(),
                    version_start: String::new(),
                    version_end: String::new(),
                }],
                actively_exploited: true,
                epss_score: None,
            },
            CveRecord {
                cve_id: "CVE-2024-0002".into(),
                severity: "low".into(),
                cvss: 3.0,
                affected_packages: vec![AffectedPackageRange {
                    product: "curl".into(),
                    version_start: String::new(),
                    version_end: String::new(),
                }],
                actively_exploited: false,
                epss_score: None,
            },
        ]);

        assert!(db.has_critical_cve("openssl")); // actively exploited + high CVSS
        assert!(!db.has_critical_cve("curl")); // not actively exploited
        assert!(!db.has_critical_cve("nginx")); // not in database
    }

    #[test]
    fn check_module_path_resolves_libraries() {
        let mut db = CveDatabase::new();
        db.load([CveRecord {
            cve_id: "CVE-2024-0001".into(),
            severity: "critical".into(),
            cvss: 9.8,
            affected_packages: vec![AffectedPackageRange {
                product: "openssl".into(),
                version_start: String::new(),
                version_end: String::new(),
            }],
            actively_exploited: true,
            epss_score: None,
        }]);

        assert!(db.check_module_path("/usr/lib/x86_64-linux-gnu/libssl.so.3"));
        assert!(db.check_module_path("/lib/libcrypto.so.3.0.0"));
        assert!(!db.check_module_path("/usr/lib/libfoo.so.1"));
    }

    #[test]
    fn extract_product_candidates_examples() {
        let c = extract_product_candidates("/usr/lib/libssl.so.3");
        assert!(c.contains(&"openssl".to_string()));

        let c = extract_product_candidates("/usr/lib/libcurl.so.4.8.0");
        assert!(c.contains(&"curl".to_string()));

        let c = extract_product_candidates("/usr/bin/nginx");
        assert!(c.contains(&"nginx".to_string()));
    }
}
