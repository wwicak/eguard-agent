#!/usr/bin/env python3
from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
CRITERIA = ROOT / "ACCEPTANCE_CRITERIA.md"
TESTS_DIR = ROOT / "crates" / "acceptance" / "tests"

OUT_PRESENCE = TESTS_DIR / "acceptance_criteria_generated.rs"
OUT_RUNTIME_ALL = TESTS_DIR / "ac_runtime_stubs_generated.rs"
OUT_RUNTIME_TST = TESTS_DIR / "ac_tst_runtime_stubs.rs"
OUT_RUNTIME_VER = TESTS_DIR / "ac_ver_runtime_stubs.rs"

AC_ID_RE = re.compile(r"AC-[A-Z]+-\d{3}")
CRITERION_LINE_RE = re.compile(r"^\s*-\s+\*\*(AC-[A-Z]+-\d{3})\*\*:\s*(.+?)\s*$")

IGNORE_REASON_BY_PREFIX = {
    "ASM": "requires asm/ffi differential and soak harness",
    "ATP": "requires hardening/tamper environment",
    "TST": "requires docker-compose integration environment",
    "VER": "requires benchmark/security verification environment",
}
DEFAULT_IGNORE_REASON = "requires integrated runtime harness"


@dataclass(frozen=True)
class Criterion:
    ac_id: str
    description: str


def extract_all_ids(text: str) -> list[str]:
    ids = sorted(set(AC_ID_RE.findall(text)))
    if not ids:
        raise SystemExit("No AC IDs found in ACCEPTANCE_CRITERIA.md")
    return ids


def parse_criteria(text: str) -> list[Criterion]:
    criteria: list[Criterion] = []
    seen: set[str] = set()

    for line in text.splitlines():
        match = CRITERION_LINE_RE.match(line)
        if not match:
            continue

        ac_id, description = match.groups()
        if ac_id in seen:
            raise SystemExit(f"Duplicate criterion id in bullet list: {ac_id}")

        seen.add(ac_id)
        criteria.append(Criterion(ac_id=ac_id, description=description.strip()))

    if not criteria:
        raise SystemExit("No criterion bullet lines found in ACCEPTANCE_CRITERIA.md")

    criteria.sort(key=lambda item: item.ac_id)
    return criteria


def assert_criteria_match_all_ids(criteria: list[Criterion], all_ids: list[str]) -> None:
    criterion_ids = [item.ac_id for item in criteria]

    missing = sorted(set(all_ids) - set(criterion_ids))
    extra = sorted(set(criterion_ids) - set(all_ids))

    if missing or extra:
        lines: list[str] = [
            "Criterion bullet extraction mismatch.",
            f"missing_from_bullets={missing}",
            f"extra_in_bullets={extra}",
        ]
        raise SystemExit("\n".join(lines))



def to_fn_name(ac_id: str) -> str:
    return ac_id.lower().replace("-", "_")



def rust_string(value: str) -> str:
    return (
        value.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("\n", "\\n")
        .replace("\r", "\\r")
        .replace("\t", "\\t")
    )



def prefix_of(ac_id: str) -> str:
    parts = ac_id.split("-")
    if len(parts) < 3:
        return ""
    return parts[1]



def ignore_reason_for(ac_id: str) -> str:
    return IGNORE_REASON_BY_PREFIX.get(prefix_of(ac_id), DEFAULT_IGNORE_REASON)



def render_presence_and_integrity(criteria: list[Criterion]) -> str:
    ids = [item.ac_id for item in criteria]

    lines: list[str] = []
    lines.append("// Generated by scripts/generate_acceptance_tests.py. Do not edit manually.")
    lines.append("")
    lines.append('const ACCEPTANCE_DOC: &str = include_str!("../../../ACCEPTANCE_CRITERIA.md");')
    lines.append('const ALL_RUNTIME_STUBS: &str = include_str!("ac_runtime_stubs_generated.rs");')
    lines.append('const TST_RUNTIME_STUBS: &str = include_str!("ac_tst_runtime_stubs.rs");')
    lines.append('const VER_RUNTIME_STUBS: &str = include_str!("ac_ver_runtime_stubs.rs");')
    lines.append("")
    lines.append("const EXPECTED_IDS: &[&str] = &[")
    for ac_id in ids:
        lines.append(f'    "{ac_id}",')
    lines.append("];")
    lines.append("")
    lines.append("fn extract_document_ids(doc: &str) -> Vec<String> {")
    lines.append("    let mut ids = Vec::new();")
    lines.append("    let bytes = doc.as_bytes();")
    lines.append("    let mut i = 0usize;")
    lines.append("")
    lines.append("    while i + 10 <= bytes.len() {")
    lines.append("        if bytes[i] == b'A' && bytes[i + 1] == b'C' && bytes[i + 2] == b'-' {")
    lines.append("            let mut j = i + 3;")
    lines.append("            while j < bytes.len() && bytes[j].is_ascii_uppercase() {")
    lines.append("                j += 1;")
    lines.append("            }")
    lines.append("")
    lines.append("            if j < bytes.len() && bytes[j] == b'-' && j + 4 <= bytes.len() {")
    lines.append("                let k = j + 1;")
    lines.append("                if bytes[k..k + 3].iter().all(u8::is_ascii_digit) {")
    lines.append("                    let id = &doc[i..k + 3];")
    lines.append("                    ids.push(id.to_string());")
    lines.append("                    i = k + 3;")
    lines.append("                    continue;")
    lines.append("                }")
    lines.append("            }")
    lines.append("        }")
    lines.append("        i += 1;")
    lines.append("    }")
    lines.append("")
    lines.append("    ids.sort();")
    lines.append("    ids.dedup();")
    lines.append("    ids")
    lines.append("}")
    lines.append("")
    lines.append("fn expected_ids() -> Vec<String> {")
    lines.append("    EXPECTED_IDS")
    lines.append("        .iter()")
    lines.append("        .map(|id| id.to_string())")
    lines.append("        .collect::<Vec<_>>()")
    lines.append("}")
    lines.append("")
    lines.append("fn expected_ids_by_prefix(prefix: &str) -> Vec<String> {")
    lines.append("    EXPECTED_IDS")
    lines.append("        .iter()")
    lines.append("        .filter(|id| id.starts_with(prefix))")
    lines.append("        .map(|id| id.to_string())")
    lines.append("        .collect::<Vec<_>>()")
    lines.append("}")
    lines.append("")
    lines.append("#[test]")
    lines.append("fn generated_id_list_matches_acceptance_document() {")
    lines.append("    assert_eq!(")
    lines.append("        extract_document_ids(ACCEPTANCE_DOC),")
    lines.append("        expected_ids(),")
    lines.append("        \"regenerate acceptance tests after AC document updates\"")
    lines.append("    );")
    lines.append("}")
    lines.append("")
    lines.append("#[test]")
    lines.append("fn runtime_stub_ids_match_acceptance_document() {")
    lines.append("    assert_eq!(")
    lines.append("        extract_document_ids(ALL_RUNTIME_STUBS),")
    lines.append("        expected_ids(),")
    lines.append("        \"ac_runtime_stubs_generated.rs must cover every AC id\"")
    lines.append("    );")
    lines.append("}")
    lines.append("")
    lines.append("#[test]")
    lines.append("fn ac_tst_runtime_stub_ids_match_acceptance_document() {")
    lines.append("    assert_eq!(")
    lines.append("        extract_document_ids(TST_RUNTIME_STUBS),")
    lines.append('        expected_ids_by_prefix("AC-TST-"),')
    lines.append("        \"ac_tst_runtime_stubs.rs must cover every AC-TST id\"")
    lines.append("    );")
    lines.append("}")
    lines.append("")
    lines.append("#[test]")
    lines.append("fn ac_ver_runtime_stub_ids_match_acceptance_document() {")
    lines.append("    assert_eq!(")
    lines.append("        extract_document_ids(VER_RUNTIME_STUBS),")
    lines.append('        expected_ids_by_prefix("AC-VER-"),')
    lines.append("        \"ac_ver_runtime_stubs.rs must cover every AC-VER id\"")
    lines.append("    );")
    lines.append("}")
    lines.append("")
    lines.append("fn assert_criterion_present(ac_id: &str) {")
    lines.append("    assert!(")
    lines.append("        ACCEPTANCE_DOC.contains(ac_id),")
    lines.append("        \"missing criterion in doc: {ac_id}\"")
    lines.append("    );")
    lines.append("}")
    lines.append("")

    for ac_id in ids:
        fn_name = to_fn_name(ac_id)
        lines.append("#[test]")
        lines.append(f"fn {fn_name}_exists_in_acceptance_document() {{")
        lines.append(f'    assert_criterion_present("{ac_id}");')
        lines.append("}")
        lines.append("")

    return "\n".join(lines)



def render_runtime_stubs(
    criteria: list[Criterion],
    *,
    file_comment: str,
    function_suffix: str,
) -> str:
    lines: list[str] = []
    lines.append("// Generated by scripts/generate_acceptance_tests.py. Do not edit manually.")
    lines.append(file_comment)
    lines.append("")

    for item in criteria:
        fn_name = f"{to_fn_name(item.ac_id)}_{function_suffix}"
        reason = rust_string(ignore_reason_for(item.ac_id))
        message = rust_string(f"Implement runtime validation for {item.ac_id}: {item.description}")

        lines.append("#[test]")
        lines.append(f"#[ignore = \"{reason}\"]")
        lines.append(f"fn {fn_name}() {{")
        lines.append(f'    panic!("{{}}", "{message}");')
        lines.append("}")
        lines.append("")

    return "\n".join(lines)



def write_generated(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content)



def main() -> None:
    text = CRITERIA.read_text()
    all_ids = extract_all_ids(text)
    criteria = parse_criteria(text)
    assert_criteria_match_all_ids(criteria, all_ids)

    criteria_tst = [item for item in criteria if item.ac_id.startswith("AC-TST-")]
    criteria_ver = [item for item in criteria if item.ac_id.startswith("AC-VER-")]

    write_generated(OUT_PRESENCE, render_presence_and_integrity(criteria))
    write_generated(
        OUT_RUNTIME_ALL,
        render_runtime_stubs(
            criteria,
            file_comment="// These tests are ignored by default because they require external runtime harnesses.",
            function_suffix="runtime_validation_stub",
        ),
    )
    write_generated(
        OUT_RUNTIME_TST,
        render_runtime_stubs(
            criteria_tst,
            file_comment="// Focused AC-TST stubs (ignored by default; require docker-compose integration).",
            function_suffix="runtime_stub",
        ),
    )
    write_generated(
        OUT_RUNTIME_VER,
        render_runtime_stubs(
            criteria_ver,
            file_comment="// Focused AC-VER stubs (ignored by default; require benchmark/security verification).",
            function_suffix="runtime_stub",
        ),
    )

    print(f"wrote {OUT_PRESENCE} with {len(criteria)} tests + integrity checks")
    print(f"wrote {OUT_RUNTIME_ALL} with {len(criteria)} ignored runtime stubs")
    print(f"wrote {OUT_RUNTIME_TST} with {len(criteria_tst)} ignored runtime stubs")
    print(f"wrote {OUT_RUNTIME_VER} with {len(criteria_ver)} ignored runtime stubs")


if __name__ == "__main__":
    main()
